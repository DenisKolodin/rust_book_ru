<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Compound Data Types</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Основной уровень</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Привязка переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Коментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Составные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с шаблоном (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, Вектора, Слайсы/Срезы</a>
</li>
<li><a href='standard-input.html'><b>2.13.</b> Стандартный ввод/вывод</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний уровень</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и Модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='closures.html'><b>3.8.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.9.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.10.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.11.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.12.</b> Статическая и Динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.13.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.14.</b> Concurrency</a>
</li>
<li><a href='error-handling.html'><b>3.15.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.16.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый уровень</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> FFI</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
<li><a href='plugins.html'><b>4.4.</b> Плагины компилятора</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>5.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>6.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Compound Data Types</h1>
    <p>Rust, like many programming languages, has a number of different data types
that are built-in. You&#39;ve already done some simple work with integers and
strings, but next, let&#39;s talk about some more complicated ways of storing data.</p>

<h2 id="tuples" class='section-header'><a
                           href="#tuples">Tuples</a></h2>
<p>The first compound data type we&#39;re going to talk about is called the <em>tuple</em>.
A tuple is an ordered list of fixed size. Like this:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>The parentheses and commas form this two-length tuple. Here&#39;s the same code, but
with the type annotated:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);
</pre>

<p>As you can see, the type of a tuple looks just like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple.
You have briefly seen <code>&amp;str</code> used as a type before, and we&#39;ll discuss the
details of strings later. In systems programming languages, strings are a bit
more complex than in other languages. For now, just read <code>&amp;str</code> as a <em>string
slice</em>, and we&#39;ll learn more soon.</p>

<p>You can access the fields in a tuple through a <em>destructuring let</em>. Here&#39;s
an example:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);
</pre>

<p>Remember before when I said the left-hand side of a <code>let</code> statement was more
powerful than just assigning a binding? Here we are. We can put a pattern on
the left-hand side of the <code>let</code>, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, <code>let</code> &quot;destructures,&quot;
or &quot;breaks up,&quot; the tuple, and assigns the bits to three bindings.</p>

<p>This pattern is very powerful, and we&#39;ll see it repeated more later.</p>

<p>There are also a few things you can do with a tuple as a whole, without
destructuring. You can assign one tuple into another, if they have the same
contained types and <a href="./glossary.html#arity">arity</a>. Tuples have the same arity when they have the same
length.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;
</pre>

<p>You can also check for equality with <code>==</code>. Again, this will only compile if the
tuples have the same type.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>2</span>, <span class='number'>4</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;yes&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;no&quot;</span>);
}
</pre>

<p>This will print <code>no</code>, because some of the values aren&#39;t equal.</p>

<p>Note that the order of the values is considered when checking for equality,
so the following example will also print <code>no</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>1</span>, <span class='number'>3</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;yes&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;no&quot;</span>);
}
</pre>

<p>One other use of tuples is to return multiple values from a function:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>next_two</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> (<span class='ident'>i32</span>, <span class='ident'>i32</span>) { (<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> <span class='ident'>next_two</span>(<span class='number'>5</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x, y = {}, {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
}
</pre>

<p>Even though Rust functions can only return one value, a tuple <em>is</em> one value,
that happens to be made up of more than one value. You can also see in this
example how you can destructure a pattern returned by a function, as well.</p>

<p>Tuples are a very simple data structure, and so are not often what you want.
Let&#39;s move on to their bigger sibling, structs.</p>

<h2 id="structs" class='section-header'><a
                           href="#structs">Structs</a></h2>
<p>A struct is another form of a <em>record type</em>, just like a tuple. There&#39;s a
difference: structs give each element that they contain a name, called a
<em>field</em> or a <em>member</em>. Check it out:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> }; <span class='comment'>// origin: Point</span>

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The origin is at ({}, {})&quot;</span>, <span class='ident'>origin</span>.<span class='ident'>x</span>, <span class='ident'>origin</span>.<span class='ident'>y</span>);
}
</pre>

<p>There&#39;s a lot going on here, so let&#39;s break it down. We declare a struct with
the <code>struct</code> keyword, and then with a name. By convention, structs begin with a
capital letter and are also camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>

<p>We can create an instance of our struct via <code>let</code>, as usual, but we use a <code>key:
value</code> style syntax to set each field. The order doesn&#39;t need to be the same as
in the original declaration.</p>

<p>Finally, because fields have names, we can access the field through dot
notation: <code>origin.x</code>.</p>

<p>The values in structs are immutable by default, like other bindings in Rust.
Use <code>mut</code> to make them mutable:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The point is at ({}, {})&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>, <span class='ident'>point</span>.<span class='ident'>y</span>);
}
</pre>

<p>This will print <code>The point is at (5, 0)</code>.</p>

<h2 id="tuple-structs-and-newtypes" class='section-header'><a
                           href="#tuple-structs-and-newtypes">Tuple Structs and Newtypes</a></h2>
<p>Rust has another data type that&#39;s like a hybrid between a tuple and a struct,
called a <em>tuple struct</em>. Tuple structs do have a name, but their fields don&#39;t:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
</pre>

<p>These two will not be equal, even if they have the same values:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>black</span> <span class='op'>=</span> <span class='ident'>Color</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
</pre>

<p>It is almost always better to use a struct than a tuple struct. We would write
<code>Color</code> and <code>Point</code> like this instead:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span> {
    <span class='ident'>red</span>: <span class='ident'>i32</span>,
    <span class='ident'>blue</span>: <span class='ident'>i32</span>,
    <span class='ident'>green</span>: <span class='ident'>i32</span>,
}

<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
    <span class='ident'>z</span>: <span class='ident'>i32</span>,
}
</pre>

<p>Now, we have actual names, rather than positions. Good names are important,
and with a struct, we have actual names.</p>

<p>There <em>is</em> one case when a tuple struct is very useful, though, and that&#39;s a
tuple struct with only one element. We call this the <em>newtype</em> pattern, because
it allows you to create a new type, distinct from that of its contained value
and expressing its own semantic meaning:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>i32</span>);

<span class='kw'>let</span> <span class='ident'>length</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);

<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;length is {} inches&quot;</span>, <span class='ident'>integer_length</span>);
</pre>

<p>As you can see here, you can extract the inner integer type through a
destructuring <code>let</code>, as we discussed previously in &#39;tuples.&#39; In this case, the
<code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>.</p>

<h2 id="enums" class='section-header'><a
                           href="#enums">Enums</a></h2>
<p>Finally, Rust has a &quot;sum type&quot;, an <em>enum</em>. Enums are an incredibly useful
feature of Rust, and are used throughout the standard library. An <code>enum</code> is
a type which relates a set of alternates to a specific name. For example, below
we define <code>Character</code> to be either a <code>Digit</code> or something else. These
can be used via their fully scoped names: <code>Character::Other</code> (more about <code>::</code>
below).</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Character</span> {
    <span class='ident'>Digit</span>(<span class='ident'>i32</span>),
    <span class='ident'>Other</span>,
}
</pre>

<p>Most normal types are allowed as the variant components of an <code>enum</code>. Here are
some examples:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Empty</span>;
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Length</span>(<span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Status</span> { <span class='ident'>Health</span>: <span class='ident'>i32</span>, <span class='ident'>Mana</span>: <span class='ident'>i32</span>, <span class='ident'>Attack</span>: <span class='ident'>i32</span>, <span class='ident'>Defense</span>: <span class='ident'>i32</span> }
<span class='kw'>struct</span> <span class='ident'>HeightDatabase</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>);
</pre>

<p>You see that, depending on its type, an <code>enum</code> variant may or may not hold data.
In <code>Character</code>, for instance, <code>Digit</code> gives a meaningful name for an <code>i32</code>
value, where <code>Other</code> is only a name. However, the fact that they represent
distinct categories of <code>Character</code> is a very useful property.</p>

<p>As with structures, the variants of an enum by default are not comparable with
equality operators (<code>==</code>, <code>!=</code>), have no ordering (<code>&lt;</code>, <code>&gt;=</code>, etc.), and do not
support other binary operations such as <code>*</code> and <code>+</code>. As such, the following code
is invalid for the example <code>Character</code> type:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='comment'>// These assignments both succeed</span>
<span class='kw'>let</span> <span class='ident'>ten</span>  <span class='op'>=</span> <span class='ident'>Character</span>::<span class='ident'>Digit</span>(<span class='number'>10</span>);
<span class='kw'>let</span> <span class='ident'>four</span> <span class='op'>=</span> <span class='ident'>Character</span>::<span class='ident'>Digit</span>(<span class='number'>4</span>);

<span class='comment'>// Error: `*` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>forty</span> <span class='op'>=</span> <span class='ident'>ten</span> <span class='op'>*</span> <span class='ident'>four</span>;

<span class='comment'>// Error: `&lt;=` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>four_is_smaller</span> <span class='op'>=</span> <span class='ident'>four</span> <span class='op'>&lt;=</span> <span class='ident'>ten</span>;

<span class='comment'>// Error: `==` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>four_equals_ten</span> <span class='op'>=</span> <span class='ident'>four</span> <span class='op'>==</span> <span class='ident'>ten</span>;
</pre>

<p>This may seem rather limiting, but it&#39;s a limitation which we can overcome.
There are two ways: by implementing equality ourselves, or by pattern matching
variants with <a href="./match.html"><code>match</code></a> expressions, which you&#39;ll learn in the next
chapter. We don&#39;t know enough about Rust to implement equality yet, but we can
use the <code>Ordering</code> enum from the standard library, which does:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Ordering</span> {
    <span class='ident'>Less</span>,
    <span class='ident'>Equal</span>,
    <span class='ident'>Greater</span>,
}
</pre>

<p>Because <code>Ordering</code> has already been defined for us, we will import it with the
<code>use</code> keyword. Here&#39;s an example of how it is used:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// ordering: Ordering</span>

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Less</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
    }
}
</pre>

<p>The <code>::</code> symbol is used to indicate a namespace. In this case, <code>Ordering</code> lives
in the <code>cmp</code> submodule of the <code>std</code> module. We&#39;ll talk more about modules later
in the guide. For now, all you need to know is that you can <code>use</code> things from
the standard library if you need them.</p>

<p>Okay, let&#39;s talk about the actual code in the example. <code>cmp</code> is a function that
compares two things, and returns an <code>Ordering</code>. We return either
<code>Ordering::Less</code>, <code>Ordering::Greater</code>, or <code>Ordering::Equal</code>, depending on
whether the first value is less than, greater than, or equal to the second. Note
that each variant of the <code>enum</code> is namespaced under the <code>enum</code> itself: it&#39;s
<code>Ordering::Greater</code>, not <code>Greater</code>.</p>

<p>The <code>ordering</code> variable has the type <code>Ordering</code>, and so contains one of the
three values. We then do a bunch of <code>if</code>/<code>else</code> comparisons to check which
one it is.</p>

<p>This <code>Ordering::Greater</code> notation is too long. Let&#39;s use another form of <code>use</code>
to import the <code>enum</code> variants instead. This will avoid full scoping:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>::{<span class='self'>self</span>, <span class='ident'>Equal</span>, <span class='ident'>Less</span>, <span class='ident'>Greater</span>};

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// ordering: Ordering</span>

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>); }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>); }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>); }
}
</pre>

<p>Importing variants is convenient and compact, but can also cause name conflicts,
so do this with caution. For this reason, it&#39;s normally considered better style
to <code>use</code> an enum rather than its variants directly.</p>

<p>As you can see, <code>enum</code>s are quite a powerful tool for data representation, and
are even more useful when they&#39;re <a href="./generics.html">generic</a> across types. Before we
get to generics, though, let&#39;s talk about how to use enums with pattern
matching, a tool that will let us deconstruct sum types (the type theory term
for enums) like <code>Ordering</code> in a very elegant way that avoids all these messy
and brittle <code>if</code>/<code>else</code>s.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceeding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>