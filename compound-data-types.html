<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Агрегатные типы данных</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Агрегатные типы данных</h1>
    <p>Как и во многих других языках программирования, в Rust есть несколько встроенных
типов данных. Вы уже работали с целыми числами и строками, а теперь мы поговорим
о более сложных способах хранения данных.</p>

<h2 id="Кортежи" class='section-header'><a
                           href="#Кортежи">Кортежи</a></h2>
<p>Первый агрегатный тип данных, о котором мы поговорим - это <em>кортеж</em>. Кортеж -
это упорядоченный список фиксированного размера. Вроде такого:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;привет&quot;</span>);
</pre>

<p>Этот кортеж из двух элементов создан с помощью скобок и запятой между
элементами. Вот тот же код, но с аннотациями типов:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;привет&quot;</span>);
</pre>

<p>Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в
этом кортеже одновременно хранятся значения типов <code>i32</code> и <code>&amp;str</code>. Мы уже
встречали тип <code>&amp;str</code> ранее, и мы обсудим строки подробнее далее. В языках
системного программирования строки немного более сложны, чем в других языках.
Пока вы можете читать <code>&amp;str</code> как <em>срез строки</em>. Мы вскоре узнаем об этом больше.</p>

<p>Доступ к полям кортежа можно получить с помощью <em>деконструирующего let</em>. Вот
пример:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x это {}&quot;</span>, <span class='ident'>x</span>);
</pre>

<p>Помните, я говорил, что левая часть оператора <code>let</code> более полезна, чем просто
присваивание имени? Об этом я и говорил. Мы можем написать слева от <code>let</code>
образец, и, если он совпадает со значением справа, произойдёт присваивание имён
сразу нескольким значениям. В данном случае, <code>let</code> &quot;деконструирует&quot; или
&quot;разбивает&quot; кортеж, и присваивает его части трём именам.</p>

<p>Это очень удобный шаблон программирования, и мы ещё не раз увидим его.</p>

<p>Некоторые вещи можно делать с кортежами как с единым целым, без разбиения. Можно
присваивать один кортеж другому, если они содержат значения одинаковых типов и
имеют одинаковую <a href="./glossary.html#arity">арность</a>. Арность кортежей одинакова, когда их длина
совпадает.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;
</pre>

<p>Вы также можете проверять кортежи на равенство с помощью операции <code>==</code>. Опять-
таки, это скомпилируется только если кортежи имеют одинаковые типы.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>2</span>, <span class='number'>4</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;да&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;нет&quot;</span>);
}
</pre>

<p>Этот код напечатает <code>нет</code>, потому что некоторые элементы не равны.</p>

<p>Заметьте, что порядок элементов важен при сравнении кортежей, поэтому в
следующем примере код также напечатает <code>нет</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>1</span>, <span class='number'>3</span>);

<span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;да&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;нет&quot;</span>);
}
</pre>

<p>Другой способ использовать кортежи - это возврат множества значений из функции:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>next_two</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> (<span class='ident'>i32</span>, <span class='ident'>i32</span>) { (<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>2</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> <span class='ident'>next_two</span>(<span class='number'>5</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x, y = {}, {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
}
</pre>

<p>Несмотря на то, что функции в Rust могут возвращать только одно значение, в
данном случае это не помеха. Кортеж - это <em>одно</em> значение, которое состоит из
нескольких. В этом примере вы также можете видеть пример разбиения кортежа,
возвращаемого функцией.</p>

<p>Кортежи - это очень простая структура данных, и часто они вам не подойдут.
Давайте рассмотрим их старшего брата, структуры.</p>

<h2 id="Структуры" class='section-header'><a
                           href="#Структуры">Структуры</a></h2>
<p>Структура - это другой вид <em>агрегатного типа</em>, как и кортеж. Разница в том, что
в структурах у каждого элемента есть имя. Элемент структуры называется <em>полем</em>
или <em>членом структуры</em>. Смотрите:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> }; <span class='comment'>// origin: Point</span>

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Начало координат находится в ({}, {})&quot;</span>, <span class='ident'>origin</span>.<span class='ident'>x</span>, <span class='ident'>origin</span>.<span class='ident'>y</span>);
}
</pre>

<p>Этот код делает много разных вещей, поэтому давайте разберём его по порядку. Мы
объявляем структуру с помощью ключевого слова <code>struct</code>, за которым следует имя
объявляемой структуры. Обычно, имена типов-структур начинаются с заглавной буквы
и используют чередующийся регистр букв: название <code>PointInSpace</code> выглядит
привычно, а <code>Point_In_Space</code> - нет.</p>

<p>Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора
<code>let</code>. Однако в данном случае мы используем синтаксис вида <code>ключ: значение</code> для
установки значения каждого поля. Порядок инициализации полей не обязательно
должен совпадать с порядком их объявления.</p>

<p>Наконец, поскольку у полей есть имена, мы можем получить поле с помощью операции
<code>точка</code>: <code>origin.x</code>.</p>

<p>Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не
отличаются от других именованных сущностей. Чтобы они стали изменяемы,
используйте ключевое слово <code>mut</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Точка находится в ({}, {})&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>, <span class='ident'>point</span>.<span class='ident'>y</span>);
}
</pre>

<p>Этот код напечатает <code>Точка находится в (5, 0)</code>.</p>

<h2 id="Кортежные-структуры-и-новые-типы" class='section-header'><a
                           href="#Кортежные-структуры-и-новые-типы">Кортежные структуры и новые типы</a></h2>
<p>В Rust есть ещё один тип данных, который представляет собой нечто среднее между
кортежем и структурой. Он называется <em>кортежной структурой</em>. Кортежные структуры
именуются, а вот у их полей имён нет:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
</pre>

<p>Эти два объекта различны, несмотря на то, что у них одинаковые значения:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>black</span> <span class='op'>=</span> <span class='ident'>Color</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
</pre>

<p>Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
Мы бы скорее объявили типы <code>Color</code> и <code>Point</code> вот так:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Color</span> {
    <span class='ident'>red</span>: <span class='ident'>i32</span>,
    <span class='ident'>blue</span>: <span class='ident'>i32</span>,
    <span class='ident'>green</span>: <span class='ident'>i32</span>,
}

<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
    <span class='ident'>z</span>: <span class='ident'>i32</span>,
}
</pre>

<p>Теперь у нас есть настоящие имена, а не только позиции. Хорошие имена важны, и
при использовании структуры у нас есть эти имена.</p>

<p>Однако, <em>есть</em> один случай, когда кортежные структуры очень полезны. Это
кортежная структура с всего одним элементом. Такое использование называется
<em>новым типом</em>, потому что оно позволяет создать новый тип, отличный от типа
значения, содержащегося в кортежной структуре. При этом новый тип обозначает
что-то другое:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>i32</span>);

<span class='kw'>let</span> <span class='ident'>length</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);

<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Длина в дюймах: {}&quot;</span>, <span class='ident'>integer_length</span>);
</pre>

<p>Как вы можете видеть в данном примере, извлечь вложенный целый тип можно с
помощью деконструирующего <code>let</code>. Мы обсуждали это выше, в разделе &quot;кортежи&quot;. В
данном случае, оператор <code>let Inches(integer_length)</code> присваивает <code>10</code> имени
<code>integer_length</code>.</p>

<h2 id="Перечисления" class='section-header'><a
                           href="#Перечисления">Перечисления</a></h2>
<p>Наконец, в Rust есть &quot;типы-суммы&quot;, или <em>перечисления</em> (тип-сумма - это термин из
теории типов). Перечисления - это очень полезная возможность Rust, и они очень
много используются в стандартной библиотеке языка. Они объявляются с помощью
ключевого слова <code>enum</code>. <code>enum</code> - это тип, который соотносит набор неких
вариантов одному имени. Например, ниже мы определяем перечисление <code>Character</code>
(символ), представляющее собой или цифру (<code>Digit</code>), или что-то другое.
Объявленные варианты можно использовать с помощью полностью квалифицированных
имён, таких, как <code>Character::Other</code> (мы поговорим об операции <code>::</code> ниже).</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Character</span> {
    <span class='ident'>Digit</span>(<span class='ident'>i32</span>),
    <span class='ident'>Other</span>,
}
</pre>

<p>Б&#39;ольшая часть обычных типов могут быть вариантами перечисления. Вот несколько
примеров:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Empty</span>;
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Length</span>(<span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Status</span> { <span class='ident'>Health</span>: <span class='ident'>i32</span>, <span class='ident'>Mana</span>: <span class='ident'>i32</span>, <span class='ident'>Attack</span>: <span class='ident'>i32</span>, <span class='ident'>Defense</span>: <span class='ident'>i32</span> }
<span class='kw'>struct</span> <span class='ident'>HeightDatabase</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>);
</pre>

<p>Здесь мы видим, что, в зависимости от типа, вариант перечисления может содержать
вложенные данные, а может и не иметь таковых. Например, в перечислении
<code>Character</code> (символ), вариант <code>Digit</code> (цифра) даёт значимое имя числу типа
<code>i32</code>. А вот вариант <code>Other</code> представляет собой лишь имя, без значения. Однако
наиболее полезно именно то, что отдельные варианты представляют собой отдельные
виды символов (<code>Character</code>).</p>

<p>Как и структуры, варианты перечислений по умолчанию не сравнимы операциями
сравнения (<code>==</code>, <code>!=</code>), не упорядочены (не реализуют <code>&lt;</code>, <code>&gt;=</code> и другие) и не
поддерживают другие двухместные операции, такие как умножение (<code>*</code>) и сложение
(<code>+</code>). Нижеследующий код, как таковой, не верен (если мы используем приведённый
выше тип-перечисление <code>Character</code>):</p>
<pre id='rust-example-rendered' class='rust '>
<span class='comment'>// Оба этих присваивания успешны</span>
<span class='kw'>let</span> <span class='ident'>ten</span>  <span class='op'>=</span> <span class='ident'>Character</span>::<span class='ident'>Digit</span>(<span class='number'>10</span>);
<span class='kw'>let</span> <span class='ident'>four</span> <span class='op'>=</span> <span class='ident'>Character</span>::<span class='ident'>Digit</span>(<span class='number'>4</span>);

<span class='comment'>// Error: `*` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>forty</span> <span class='op'>=</span> <span class='ident'>ten</span> <span class='op'>*</span> <span class='ident'>four</span>;

<span class='comment'>// Error: `&lt;=` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>four_is_smaller</span> <span class='op'>=</span> <span class='ident'>four</span> <span class='op'>&lt;=</span> <span class='ident'>ten</span>;

<span class='comment'>// Error: `==` is not implemented for type `Character`</span>
<span class='kw'>let</span> <span class='ident'>four_equals_ten</span> <span class='op'>=</span> <span class='ident'>four</span> <span class='op'>==</span> <span class='ident'>ten</span>;
</pre>

<p>Наверное, это выглядит неудобным. Но мы можем преодолеть данное ограничение.
Есть два способа сделать это: реализовать сравнение самим, или использовать
сопоставление вариантов с образцом с помощью выражений <a href="./match.html"><code>match</code></a>. Мы
узнаем о них в следующей главе. Пока мы не имеем достаточных знаний Rust для
реализации сравнения. Но мы можем использовать перечисление <code>Ordering</code> (порядок)
из стандартной библиотеки, которое выглядит так:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Ordering</span> {
    <span class='ident'>Less</span>,
    <span class='ident'>Equal</span>,
    <span class='ident'>Greater</span>,
}
</pre>

<p>Поскольку перечисление <code>Ordering</code> уже определено, мы импортируем его с помощью
ключевого слова <code>use</code>. Вот пример его использования:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>;

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// ordering: Ordering</span>

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Less</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;меньше&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Greater</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;больше&quot;</span>);
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Ordering</span>::<span class='ident'>Equal</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;равно&quot;</span>);
    }
}
</pre>

<p>Мы используем символ <code>::</code> для обозначения пространства имён. В данном случае,
перечисление <code>Ordering</code> находится в под-модуле модуля <code>std</code>. Мы подробнее
поговорим о модулях позже. Пока же достаточно знать, что вы можете использовать
(<code>use</code>) вещи из стандартной библиотеки, если они вам понадобятся.</p>

<p>Отлично, теперь давайте поговорим о самом коде примера. <code>cmp</code> - это функция,
которая сравнивает два объекта, и возвращает значение типа &quot;порядок&quot;
(<code>Ordering</code>). Мы возвращаем одно из значений <code>Ordering::Less</code>,
<code>Ordering::Greater</code> или <code>Ordering::Equal</code>, когда первое значение меньше, больше
или равно второму, соответственно. Заметьте, что варианты перечисления находятся
в пространстве имён самого перечисления: к нему нужно обращаться
<code>Ordering::Greater</code>, а не <code>Greater</code>.</p>

<p>Переменная <code>ordering</code> имеет тип <code>Ordering</code>, и содержит одно из трёх значений.
Затем мы делаем несколько сравнений с помощью <code>if</code>/<code>else</code>, чтобы проверить,
какое из значений мы получили.</p>

<p>Запись <code>Ordering::Greater</code> неудобна из-за своей длины. Давайте используем другой
вид оператора <code>use</code> и импортируем сами варианты перечисления. В таком коде не
нужно полностью специфицировать имена вариантов:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>Ordering</span>::{<span class='self'>self</span>, <span class='ident'>Equal</span>, <span class='ident'>Less</span>, <span class='ident'>Greater</span>};

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span> { <span class='ident'>Equal</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>10</span>;

    <span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// ordering: Ordering</span>

    <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;меньше&quot;</span>); }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;больше&quot;</span>); }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;равно&quot;</span>); }
}
</pre>

<p>Импорт вариантов удобен и компактен, но он может вызывать конфликты имён,
поэтому будьте осторожны при его использовании. Обычно стилистически лучше
импортировать перечисление, а не его варианты.</p>

<p>Как видите, перечисления довольно удобны, и особенно полезны когда они
<a href="./generics.html">обобщены</a> относительно вложенных в них типов. Однако, прежде чем мы
перейдём к рассмотрению обобщённых типов, давайте поговорим об использовании
перечислений при сопоставлении с образцом. Сопоставление с образцом - это
инструмент, позволяющий нам элегантно разбирать типы-суммы вроде <code>Ordering</code>.
Данная техника позволит нам избежать всех этих хрупких сравнений с помощью
<code>if</code>/<code>else</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>