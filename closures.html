<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Замыкания</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Замыкания</h1>
    <p>К этому моменту мы уже создали много функций в Rust, но мы дали им всем имена.
Rust также позволяет нам создавать анонимные функции. В Rust анонимные функции,
называются <em>замыкания</em>. Сами по себе замыкания не предсталяют большого интереса,
но, когда вы объединяете их с функциями, которые принимают замыкания в качестве
аргументов, то становится возможным создавать по-настоящему мощные вещи.</p>

<p>Давайте создадим замыкание:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>add_one</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> { <span class='number'>1</span> <span class='op'>+</span> <span class='ident'>x</span> };

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The sum of 5 plus 1 is {}.&quot;</span>, <span class='ident'>add_one</span>(<span class='number'>5</span>));
</pre>

<p>Мы создаем замыкание с помощью <code>|...| { ... }</code> синтаксиса, а затем связываем его
с именем, поэтому мы можем использовать его позже. Обратите внимание, что мы
вызываем функцию с помощью связанного имени и двух круглых скобок, точно так же,
как мы бы делали это для именонанной функции.</p>

<p>Давайте сравним синтаксис. Они довольно близки:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>add_one</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>1</span> <span class='op'>+</span> <span class='ident'>x</span> };
<span class='kw'>fn</span>  <span class='ident'>add_one</span>   (<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>1</span> <span class='op'>+</span> <span class='ident'>x</span> }
</pre>

<p>Как вы могли заметить, замыкание самостоятельно выводит типы аргументов и
возвращаемого значения, так что вам не обязательно объявлять один. Это отличает
их от именованных функций, которые по умолчанию возвращения блок (<code>()</code>).</p>

<p>Но есть одна большая разница между замыканием и именованной функцией, название
говорит само за себя: замыкание &quot;замыкает в себе свое окружение.&quot; Что это
значит? Это означает следующее:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>printer</span> <span class='op'>=</span> <span class='op'>||</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>); };

    <span class='ident'>printer</span>(); <span class='comment'>// prints &quot;x is: 5&quot;</span>
}
</pre>

<p>Синтаксис <code>||</code> означает, что это замыкание, которое не принимает никаких
аргументов. Без него мы бы просто получили блок кода, заключенный в <code>{}</code>.</p>

<p>Другими словами, замыкание имеет доступ к переменным в области определения, где
оно определено. Замыкание заимствует все переменные, которые оно использует, так
что это будет ошибка:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>printer</span> <span class='op'>=</span> <span class='op'>||</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>); };

    <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>6</span>; <span class='comment'>// error: cannot assign to `x` because it is borrowed</span>
}
</pre>

<h2 id="Перемещающие-замыкания" class='section-header'><a
                           href="#Перемещающие-замыкания">Перемещающие замыкания</a></h2>
<p>В Rust есть второй тип замыканий, называемых <em>перемещающие замыкания</em>.
Перемещающие замыкания определяются с помощью ключевого слова <code>move</code> (например,
<code>move || x * x</code>). Разница между перемещающим и обычным замыканиями в том, что
перемещающее замыкание становится владельцем всех переменных, которые оно
использует. Обычное замыкание, напротив, просто создает ссылку в замыкнутом
кадре стека. Перемещающие замыкания являются наиболее полезными в сочетании с
особенностями параллелизма Rust, и поэтому мы просто оставим эту тему сейчас. Мы
поговорим о них более подробно в главе &quot;параллелизм&quot; этой книги.</p>

<h2 id="Передача-замыканий-в-качестве-аргументов" class='section-header'><a
                           href="#Передача-замыканий-в-качестве-аргументов">Передача замыканий в качестве аргументов</a></h2>
<p>Замыкания являются наиболее полезными, если использовать их в качестве аргумента
другой функции. Вот пример:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>twice</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>f</span>(<span class='ident'>x</span>) <span class='op'>+</span> <span class='ident'>f</span>(<span class='ident'>x</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>square</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> { <span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span> };

    <span class='ident'>twice</span>(<span class='number'>5</span>, <span class='ident'>square</span>); <span class='comment'>// evaluates to 50</span>
}
</pre>

<p>Давайте разберем пример, начиная с <code>main</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>square</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> { <span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span> };
</pre>

<p>Мы уже видели подобное раньше. Мы создаем замыкание, принимающее целое число, и
возвращающее квадрат этого числа.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='ident'>twice</span>(<span class='number'>5</span>, <span class='ident'>square</span>); <span class='comment'>// evaluates to 50</span>
</pre>

<p>Эта строка более интересна. Здесь мы вызываем нашу функцию <code>twice</code>, и передаем
ей два аргумента: целое число, <code>5</code>, и наш замыкание, <code>square</code>. Это аналогично
передачи в функцию каких-либо двух других связанных переменных, но если вы
никогда не работали с замыканиями ранее, это может показаться немного сложным.
Подумайте только: &quot;Я передаю две переменные: одна i32, а другая функция.&quot;</p>

<p>Далее, давайте посмотрим на то, как <code>twice</code> определяется:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>twice</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
</pre>

<p><code>twice</code> принимает два аргумента, <code>x</code> и <code>f</code>. Вот почему мы вызывали ее с двумя
аргументами. <code>x</code> имеет тип <code>i32</code>, мы имели дело с этим много раз. <code>f</code> является
функцией, которая принимает <code>i32</code> и возвращает <code>i32</code>. Это то, о чем говорит что
требование <code>Fn(i32) -&gt; i32</code> для параметра типа <code>F</code>. Теперь <code>F</code> представляет
собой <em>любую</em> функцию, которая принимает <code>i32</code> и возвращает <code>i32</code>.</p>

<p>Это самая сложная сигнатура функции из всех, которые мы видели до сих пор!
Прочтите это несколько раз, пока вы не осознаете, как это работает. Это
потребует немного практики. Хорошей новостью является то, что этот вид передачи
замыкания может быть очень эффективным. Со всеми типами, информация о которых
имеется во время компиляции, компилятор может творить чудеса.</p>

<p>Наконец, <code>twice</code> возвращает <code>i32</code>.</p>

<p>Хорошо, давайте посмотрим на тело функции <code>twice</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>twice</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
  <span class='ident'>f</span>(<span class='ident'>x</span>) <span class='op'>+</span> <span class='ident'>f</span>(<span class='ident'>x</span>)
}
</pre>

<p>Так как наше замыкание имеет имя <code>f</code>, мы можем вызывать его так же, как мы
вызывали наши замыкания прежде, и мы передаем аргумент <code>x</code> в каждый из двух
вызовов, отсюда и название <code>twice</code>.</p>

<p>If you do the math, <code>(5 * 5) + (5 * 5) == 50</code>, so that&#39;s the output we get.
Если вы сравните, <code>(5 * 5) + (5 * 5) == 50</code>, то уви так что это выходе мы
получаем.</p>

<p>Поэкспериментируйте с этой концепцией, пока вы не чувствуете себя комфортно при
работе с ней. В стандартной библиотеке Rust постоянно используются замыкания,
где это уместно, так что вы часто будете сталкиваться с этой техникой.</p>

<p>Если мы не хотим присваивать имя <code>square</code>, мы могли бы просто определить его как
встроенное замыкание. Этот пример точно такой же, как и предыдущий:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>twice</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>f</span>(<span class='ident'>x</span>) <span class='op'>+</span> <span class='ident'>f</span>(<span class='ident'>x</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>twice</span>(<span class='number'>5</span>, <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>i32</span><span class='op'>|</span> { <span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span> }); <span class='comment'>// evaluates to 50</span>
}
</pre>

<p>Везде, где используется замыкание, можно использовать именованную функцию. Ниже
приведен другой способ написания предыдущего примера:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>twice</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>f</span>(<span class='ident'>x</span>) <span class='op'>+</span> <span class='ident'>f</span>(<span class='ident'>x</span>)
}

<span class='kw'>fn</span> <span class='ident'>square</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>twice</span>(<span class='number'>5</span>, <span class='ident'>square</span>); <span class='comment'>// evaluates to 50</span>
}
</pre>

<p>Это используется не особенно часто, но время от времени это бывает полезным.</p>

<p>Прежде чем мы перейдем дальше, давайте посмотрим на функцию, которая принимает
два замыкания.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>compose</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>G</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>F</span>, <span class='ident'>g</span>: <span class='ident'>G</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>
    <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>, <span class='ident'>G</span>: <span class='ident'>Fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>g</span>(<span class='ident'>f</span>(<span class='ident'>x</span>))
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>compose</span>(<span class='number'>5</span>,
            <span class='op'>|</span><span class='ident'>n</span>: <span class='ident'>i32</span><span class='op'>|</span> { <span class='ident'>n</span> <span class='op'>+</span> <span class='number'>42</span> },
            <span class='op'>|</span><span class='ident'>n</span>: <span class='ident'>i32</span><span class='op'>|</span> { <span class='ident'>n</span> <span class='op'>*</span> <span class='number'>2</span> }); <span class='comment'>// evaluates to 94</span>
}
</pre>

<p>Вы можете задаться вопросом: почему мы использовали два параметра типа <code>F</code> и <code>G</code>
здесь? Очевидно, что оба аргумента <code>f</code> и <code>g</code> имеют одинаковую сигнатуру:
<code>Fn(i32) -&gt; i32</code>.</p>

<p>Это потому, что в Rust каждое замыкание имеет свой собственный уникальный тип.
Поэтому не только замыкания с разными сигнатурами имеют различные типы, но и
разные замыкания с <em>одинаковыми</em> сигнатурами также имеют <em>различные</em> типы!</p>

<p>Вы можете думать об этом так: поведение замыкания является частью его типа.
Таким образом, использование одного параметра типа для обоих замыканий будет
принято первым из них, но отвергнуто вторым. Отличный тип второго замыкания не
позволяет ему быть представленным тем же параметром типа, что и первое
замыкание. Мы осознаем это, и поэтому используем два разных параметра типа <code>F</code> и
<code>G</code>.</p>

<p>Этот пример также вводит статью <code>where</code>, что позволяет нам описать параметры
типов в более гибкой манере.</p>

<p>Это все, что вам нужно, чтобы работать с замыканиями! Замыкания могут показаться
немного странным на первый взгляд, но, как только вы привыкнете к ним, вам будет
не хватать их в на других языках. Передача функций в другие функции может быть
невероятно мощным, что вы увидите в следующей главе об итераторах.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>