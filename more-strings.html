<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Больше о строках</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Больше о строках</h1>
    <p>Строки - важное понятие, которое необходимо освоить в любом языке
программирования. Если вы пришли из управляемого языка, то можете быть удивлены
сложностью обработки строк в системном языке программирования. Эффективный
доступ и выделение памяти для структуры динамического размера включает в себя
много нюансов. К счастью, Rust имеет большое количество инструментов, чтобы
помочь нам в этом вопросе.</p>

<p><strong>string</strong> - это последовательность скалярных значений юникод, закодированных в
виде потока UTF-8 байт. Все строки должны быть гарантированно валидными UTF-8
последовательностями. Кроме того, строки не оканчиваются нулем и могут содержать
нулевые байты.</p>

<p>Rust имеет два основных типа строк: <code>&amp;str</code> и <code>String</code>.</p>

<h1 id="&amp;str" class='section-header'><a
                           href="#&amp;str"><code>&amp;str</code></a></h1>
<p>Первый тип строк - <code>&amp;str</code>. Это произносится как &#39;строковый слайс (срез)&#39;.
Строковые литералы имеют тип <code>&amp;str</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='string'>&quot;Hello there.&quot;</span>;
</pre>

<p>Как и любая ссылка Rust, строковые слайсы имеют связанный срок жизни. Для
строкового литерала - <code>&amp;&#39;static str</code>. Строковый слайс можно записать без явного
указания срока жизни во многих случаях, например, в качестве аргументов функций.
В этих случаях срок жизни будет выведен:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>takes_slice</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Got: {}&quot;</span>, <span class='ident'>slice</span>);
}
</pre>

<p>Как и векторные слайсы, строковые слайсы - это просто указатель плюс длина. Это
означает, что они являются &#39;видом&#39; (&#39;представлением&#39;) уже размещенной в памяти
строки, например, строковый литерал или <code>String</code>.</p>

<h2 id="str" class='section-header'><a
                           href="#str"><code>str</code></a></h2>
<p>Иногда вы можете встретить использование типа <code>str</code> без <code>&amp;</code>. Хотя этот тип
существует, это не то, что вам следует использовать самостоятельно. Иногда люди
путают <code>str</code> и <code>String</code>, и написать так:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>S</span> {
    <span class='ident'>s</span>: <span class='ident'>str</span>,
}
</pre>

<p>Это приводит к неприятным ошибкам:</p>

<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]
note: `str` does not have a constant size known at compile-time
</code></pre>

<p>Вместо этого <code>struct</code> должна быть</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>struct</span> <span class='ident'>S</span> {
    <span class='ident'>s</span>: <span class='ident'>String</span>,
}
</pre>

<p>Итак, давайте поговорим о <code>String</code>.</p>

<h1 id="string" class='section-header'><a
                           href="#string"><code>String</code></a></h1>
<p><code>String</code> - это размещенная в куче строка. Эта строка расширяема, а также
гарантированно является UTF-8. <code>String</code> обычно создаются путем преобразования из
строкового слайса при помощи метода <code>to_string</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);

<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, world.&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);
</pre>

<p>Ссылка на <code>String</code> будет автоматически приводятся к строковому слайсу:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>takes_slice</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Got: {}&quot;</span>, <span class='ident'>slice</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>takes_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
}
</pre>

<p>Вы также можете получить <code>&amp;str</code> из размещенного в стеке массива байт:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>str</span>;

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='string'>b&#39;a&#39;</span>, <span class='string'>b&#39;b&#39;</span>];
<span class='kw'>let</span> <span class='ident'>stack_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='ident'>x</span>).<span class='ident'>unwrap</span>();
</pre>

<h1 id="Лучшая-практика" class='section-header'><a
                           href="#Лучшая-практика">Лучшая практика</a></h1>
<h2 id="string-vs-&amp;str" class='section-header'><a
                           href="#string-vs-&amp;str"><code>String</code> vs <code>&amp;str</code></a></h2>
<p>В общем, следует отдавать предпочтение <code>String</code>, когда вам нужно право владения,
и <code>&amp;str</code>, когда вам нужно просто позаимствовать строку. Это очень похоже на
использование <code>Vec&lt;T&gt;</code> vs <code>&amp;[T]</code>, <code>T</code> vs <code>&amp;T</code> в общем.</p>

<p>Это означает, начинать с:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
</pre>

<p>и только затем изменять на:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='ident'>String</span>) {
</pre>

<p>если у вас есть веские основания для этого. Забирать право собственности в тех
случаях, где это не нужно, является плохой практикой. К тому же это может
сделать сроки жизни более запутанными.</p>

<h2 id="Обобщенные-функции" class='section-header'><a
                           href="#Обобщенные-функции">Обобщенные функции</a></h2>
<p>To write a function that&#39;s generic over types of strings, use <code>&amp;str</code>.
Чтобы записать функцию, которая является обобщенной по типам строк, используйте <code>&amp;str</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>some_string_length</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='ident'>x</span>.<span class='ident'>len</span>()
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello, world&quot;</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>some_string_length</span>(<span class='ident'>s</span>));

    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello, world&quot;</span>.<span class='ident'>to_string</span>();

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>some_string_length</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>));
}
</pre>

<p>Обе эти строки напечатают <code>12</code>.</p>

<h2 id="Индексация-строк" class='section-header'><a
                           href="#Индексация-строк">Индексация строк</a></h2>
<p>Вы можете захотеть попробовать получить доступ к определенному символу <code>String</code>,
например:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>to_string</span>();

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]);
</pre>

<p>Этот код не компилируется. И это не случайно. В мире UTF-8, прямая индексация
практически никогда не является тем, что вы хотите сделать. Причина в том, что
каждый символ может состоять из переменного количества байт. Это означает, что
для перебора вы в любом случае должны использовать символы, что является O(n)
операцией.</p>

<p>Существует 3 основных уровня для unicode (и его кодировок):</p>

<ul>
<li>кодовые единицы (code units), базовый тип данных, используемый для хранения
всего</li>
<li>кодовые точки/скалярные значения unicode (code points/unicode scalar values)
(символы)</li>
<li>графемы (grapheme) (визуальные символы)</li>
</ul>

<p>Rust предоставляет итераторы для каждого из этих уровней:</p>

<ul>
<li><code>.bytes()</code> будет итерировать по нижележащим байтам (code units)</li>
<li><code>.chars()</code> будет итерировать по кодовым точкам (code points)</li>
<li><code>.graphemes()</code> будет итерировать по графемам (grapheme)</li>
</ul>

<p>Как правило, метод <code>graphemes()</code> для <code>&amp;str</code> - это именно то, что вы хотите:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé&quot;</span>;

<span class='kw'>for</span> <span class='ident'>l</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>graphemes</span>(<span class='boolval'>true</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>l</span>);
}
</pre>

<p>Этот код напечатает:</p>

<pre><code class="language-text">u͔
n͈̰̎
i̙̮͚̦
c͚̉
o̼̩̰͗
d͔̆̓ͥ
é
</code></pre>

<p>Следует отметить, что <code>l</code> здесь имеет тип <code>&amp;str</code>, так как одна графема может
состоять из нескольких кодовых точек, поэтому <code>char</code> тут не будет уместен.</p>

<p>Как и следовало ожидать, этот код будет печатать каждый отображаемый символ в
порядке очереди: первым <code>u͔</code>, затем <code>n͈̰̎</code>, и т.д. Если вы хотите получить
каждую кодовую точку каждой графемы отдельно, то можете использовать <code>.chars()</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé&quot;</span>;

<span class='kw'>for</span> <span class='ident'>l</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>chars</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>l</span>);
}
</pre>

<p>Этот код напечатает:</p>

<pre><code class="language-text">u
͔
n
̎
͈
̰
i
̙
̮
͚
̦
c
̉
͚
o
͗
̼
̩
̰
d
̆
̓
ͥ
͔
e
́
</code></pre>

<p>Вы можете видеть, что некоторые из них являются комбинируемыми символами, и
поэтому их отображение выглядит немного странным.</p>

<p>Если вы хотите получить представление каждого отдельного байта для каждой
кодовой точки, то можете использовать <code>.bytes()</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé&quot;</span>;

<span class='kw'>for</span> <span class='ident'>l</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>bytes</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>l</span>);
}
</pre>

<p>Этот код напечатает:</p>

<pre><code class="language-text">117
205
148
110
204
142
205
136
204
176
105
204
153
204
174
205
154
204
166
99
204
137
205
154
111
205
151
204
188
204
169
204
176
100
204
134
205
131
205
165
205
148
101
204
129
</code></pre>

<p>Количество байт намного больше, чем графем!</p>

<h1 id="deref-приведение" class='section-header'><a
                           href="#deref-приведение"><code>Deref</code> приведение</a></h1>
<p>Ссылки на <code>String</code> автоматически приводятся к <code>&amp;str</code>. Как показано в коде ниже:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>hello</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
   <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, {}!&quot;</span>, <span class='ident'>s</span>);
}

<span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> <span class='string'>&quot;Steve&quot;</span>;
<span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='string'>&quot;Steve&quot;</span>.<span class='ident'>to_string</span>();

<span class='ident'>hello</span>(<span class='ident'>slice</span>);
<span class='ident'>hello</span>(<span class='kw-2'>&amp;</span><span class='ident'>string</span>);
</pre>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>