<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Многозадачность (параллелизм)</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Многозадачность (параллелизм)</h1>
    <p>Многозадачность и параллелизм являются невероятно важными проблемами в области
компьютерной науки. А также это актуальная тема для современной индустрии.
Компьютеры приобретают все больше и больше ядер, но многие программисты не
готовы в полной мере использовать это.</p>

<p>Средства Rust для безопасной работы с памятью в полной мере применимы и при
работе в многозадачной среде. Поэтому многозадачные программы на Rust должны
безопасно работать с памятью, и не создавать состояния гонки данных. Система
типов Rust способна справиться с этими задачами еще на этапе компиляции,
благодаря мощным средствам, которые она предоставляет.</p>

<p>Прежде чем мы поговорим об особенностях многозадачности, которые идут с Rust,
важно понять вот что: Rust является достаточно низкоуровневым, поэтому все это
предусмотрено в стандартной библиотеке, а не в самом языке. Это означает, что
если вам не нравится какой-то аспект в способе обработки многозадачности,
который использует Rust, вы всегда можете реализовать альтернативный способ.
<a href="https://github.com/carllerche/mio">mio</a> представляет реальный пример этого
принципа в действии.</p>

<h2 id="Справочная-информация:-send-и-sync" class='section-header'><a
                           href="#Справочная-информация:-send-и-sync">Справочная информация: <code>Send</code> и <code>Sync</code></a></h2>
<p>О многозадачности рассуждать довольно трудно. В Rust, у нас есть система
строгой, статической типизации, чтобы помочь нам делать выводы о нашем коде. В
связи с этим Rust дает нам два трейта, помогающих нам разбираться в коде,
который, по всей вероятности, является многозадачным.</p>

<h3 id="send" class='section-header'><a
                           href="#send"><code>Send</code></a></h3>
<p>Первый трейт, о котором мы будем говорить, называется
<a href="../std/marker/trait.Send.html"><code>Send</code></a>. Когда тип <code>T</code> реализует <code>Send</code>, это
указывает компилятору, что право владения переменными этого типа можно безопасно
перемещать между потоками.</p>

<p>Это важно для соблюдения некоторых ограничений. Например, если у нас есть канал,
соединяющий два потока, и мы хотели бы иметь возможность отправлять некоторые
данные по каналу из одного потока в другой. Следовательно, мы должны
гарантировать, что для отправляемого типа данных реализован трейт <code>Send</code>.</p>

<p>In the opposite way, if we were wrapping a library with FFI that isn&#39;t
threadsafe, we wouldn&#39;t want to implement <code>Send</code>, and so the compiler will help
us enforce that it can&#39;t leave the current thread.
И наоборот, если мы были упаковка библиотека с помощью FFI (Foreign Function
Interface), который не является потокобезопасным, мы не хотели бы реализовать
трейт <code>Send</code>, и поэтому компилятор поможет нам обеспечивать это, что нельзя
оставить текущий поток.</p>

<h3 id="sync" class='section-header'><a
                           href="#sync"><code>Sync</code></a></h3>
<p>Второй из этих трейтов называется <a href="../std/marker/trait.Sync.html"><code>Sync</code></a>. Когда
тип <code>T</code> реализует <code>Sync</code>, это указывает компилятору, что переменные этого типа
не имеют возможности использовать небезопасную память, когда они используются из
нескольких потоков одновременно.</p>

<p>Например, совместное использование неизменяемых данных с помощью атомарного
счетчика ссылок является потокобезопасным. Rust обеспечивает такой тип,
<code>Arc&lt;T&gt;</code>, и он реализует <code>Sync</code>, так что при помощи этого типа можно безопасно
обмениваться данными между потоками.</p>

<p>Эти два трейта позволяют использовать систему типов, чтобы обеспечить надежные
гарантии о свойствах вашего кода в условиях многозадачности. Прежде чем мы
продемонстрируем как, сначала мы должны узнать, как создать многозадачную
программу в Rust!</p>

<h2 id="Потоки" class='section-header'><a
                           href="#Потоки">Потоки</a></h2>
<p>Стандартная библиотека Rust предоставляет библиотеку для &#39;потоков&#39;, которая
позволяет запускать Rust код параллельно. Вот простой пример использования
<code>std::thread</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>thread</span>::<span class='ident'>scoped</span>(<span class='op'>||</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello from a thread!&quot;</span>);
    });
}
</pre>

<p>Метод <code>Thread::scoped()</code> в качестве единственного аргумента принимает замыкание,
которое выполняется в новом потоке. Он называется <code>scoped</code>, потому что этот
поток возвращает присоединенного к нему гварда:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>guard</span> <span class='op'>=</span> <span class='ident'>thread</span>::<span class='ident'>scoped</span>(<span class='op'>||</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello from a thread!&quot;</span>);
    });

    <span class='comment'>// guard goes out of scope here</span>
}
</pre>

<p>Когда <code>guard</code> выходит из области видимости, он будет блокировать выполнение до
тех пор, пока присоединенный к нему поток не закончит выполняться. Если бы мы не
хотели такого поведения, то могли бы использовать метод <code>thread::spawn()</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>old_io</span>::<span class='ident'>timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='op'>||</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello from a thread!&quot;</span>);
    });

    <span class='ident'>timer</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>milliseconds</span>(<span class='number'>50</span>));
}
</pre>

<p>Когда заканчивается функция <code>main()</code>, то завершается основной поток, в
результате чего убиваются все запущенные потоки. Для предотвращения этого мы
должны вызвать метод <code>sleep</code>.</p>

<p><a href="std/thread/struct.Builder.html#method.scoped"><code>scoped</code></a> имеет интересную
сигнатуру типа:</p>

<pre><code class="language-text">fn scoped&lt;&#39;a, T, F&gt;(self, f: F) -&gt; JoinGuard&lt;&#39;a, T&gt;
    where T: Send + &#39;a,
          F: FnOnce() -&gt; T,
          F: Send + &#39;a
</code></pre>

<p>А именно: <code>F</code>, замыкание, которое мы передаем для выполнения в новом потоке. Оно
имеет два ограничения: оно должно быть <code>FnOnce</code>, принимающей <code>()</code> и возвращающей
<code>T</code>. Ограничение <code>FnOnce</code> позволяет замыканию захватить право владения над теми
данными в родительском потоке, на которые оно ссылается (которые оно
использует). Другое ограничение состоит в том, что <code>F</code> должно быть <code>Send</code>. Мы не
можем перемещать право владения, если сам тип не думает, что это нормально.</p>

<p>Многие языки имеют возможность выполнять потоки, но это дико опасно. Есть целые
книги о том, как избежать ошибок, которые происходят от совместного
использования изменяемого состояния. В Rust снова помогает система типов,
которая предотвращает гонки данных на этапе компиляции. Давайте поговорим о том,
как же на самом деле обеспечивается совместное использование что-либо в условиях
нескольких потоков.</p>

<h2 id="Безопасное-совместное-использование-изменяемого-состояния" class='section-header'><a
                           href="#Безопасное-совместное-использование-изменяемого-состояния">Безопасное совместное использование изменяемого состояния</a></h2>
<p>Благодаря системе типов Rust, у нас есть понятие, которое звучит как ложь:
&quot;безопасное совместное использование изменяемого состояния.&quot; Многие программисты
считают, что совместное использование изменяемого состояния - это очень, очень
плохо.</p>

<p>Кто-то однажды сказал это:</p>

<blockquote>
<p>Совместно используемое изменяемое состояние является корнем всех зол.
Большинство языков пытаются решить эту проблему через &#39;изменяемое&#39; часть, но
Rust решает ее через &#39;совместно используемое&#39; часть.</p>
</blockquote>

<p>Та же самая <a href="ownership.html">система владения</a>, которая помогает предотвратить
неправильное использование указателей, также помогает исключить гонки данных,
один из худших видов ошибок многозадачности.</p>

<p>В качестве примера приведем программу на Rust, которая входила бы в состояние
гонки данных на многих языках. На Rust она не будет компилироваться:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>old_io</span>::<span class='ident'>timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u32</span>, <span class='number'>2</span>, <span class='number'>3</span>];

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>2</span> {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>timer</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>milliseconds</span>(<span class='number'>50</span>));
}
</pre>

<p>Она выдает ошибку:</p>

<pre><code class="language-text">12:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>

<p>В данном случае мы знаем, что наш код <em>должен</em> быть безопасным, но Rust в этом
не уверен. И, на самом деле, он не является безопасным: так как у нас есть
ссылка на <code>data</code> в каждом потоке, а поток становится владельцем ссылки, то у нас
есть три владельца! Это плохо. Мы можем исправить это с помощью типа <code>Arc&lt;T&gt;</code>,
который является атомарным указателем со счетчиком ссылок. &#39;атомарный&#39; означает,
что им безопасно можно обмениваться между потоками.</p>

<p><code>Arc&lt;T&gt;</code> предполагает наличие еще одного свойства у своего содержимого, чтобы
гарантировать, что его можно безопасно использовать из нескольких потоков: он
предполагает, что его содержимое реализует трейт <code>Sync</code>. В нашем случае мы также
хотим, чтобы была возможность изменять значение содержимого. Нам нужен тип,
который может обеспечить возможность изменения своего содержимого лишь одиним
пользователем единовременно. Для этого мы можем использовать тип <code>Mutex&lt;T&gt;</code>. Вот
вторая версия нашего кода. Она по-прежнему не работает, но по другой причине:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>old_io</span>::<span class='ident'>timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Mutex</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u32</span>, <span class='number'>2</span>, <span class='number'>3</span>]);

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>2</span> {
        <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>timer</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>milliseconds</span>(<span class='number'>50</span>));
}
</pre>

<p>Вот ошибка:</p>

<pre><code class="language-text">&lt;anon&gt;:11:9: 11:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard&lt;&#39;_, collections::vec::Vec&lt;u32&gt;&gt;` [E0277]
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
&lt;anon&gt;:11:9: 11:22 note: `std::sync::mutex::MutexGuard&lt;&#39;_, collections::vec::Vec&lt;u32&gt;&gt;` cannot be sent between threads safely
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
</code></pre>

<p>Вы можете видеть, <a href="std/sync/struct.Mutex.html"><code>Mutex</code></a> содержит метод
<a href="http://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a>,
который имеет следующую сигнатуру:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>lock</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LockResult</span><span class='op'>&lt;</span><span class='ident'>MutexGuard</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>
</pre>

<p>Так как трейт <code>Send</code> не был реализован для <code>MutexGuard&lt;T&gt;</code>, мы не можем
перемещать гварда через границы потоков, что и сказано в сообщении об ошибке.</p>

<p>Мы можем использовать <code>Arc&lt;T&gt;</code>, чтобы исправить это. Вот рабочая версия:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Arc</span>, <span class='ident'>Mutex</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>old_io</span>::<span class='ident'>timer</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1u32</span>, <span class='number'>2</span>, <span class='number'>3</span>]));

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>2</span> {
        <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>clone</span>();
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>timer</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>milliseconds</span>(<span class='number'>50</span>));
}
</pre>

<p>Теперь мы вызываем <code>clone()</code> для нашего <code>Arc</code>, что увеличивает внутренний
счетчик. Затем эта ручка перемещается в новый поток. Давайте более подробно
рассмотрим тело потока:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
});
</pre>

<p>Во-первых, мы вызываем метод <code>lock()</code>, который захватывает блокировку мьютекса.
Так как вызов данного метода может потерпеть неудачу, то он возвращает
<code>Result&lt;T, E&gt;</code>, но, поскольку это просто пример, мы используем <code>unwrap()</code>, чтобы
получить ссылку на данные. Реальный код должен иметь более надежную обработку
ошибок в такой ситуации. После этого мы свободно изменяем данные, так как у нас
есть блокировка.</p>

<p>Использовать в данном контексте <code>timer</code> не совсем правильно. Мы выбрали
оптимальное время ожидания. Но вполне возможно, что мы выбрали слишком высокое
время ожидания, в результате чего временные затраты на выполнение существенно
увеличиваются. Также возможно, что мы выбрали слишком низкое время ожидания, из-
за чего вычисления не будут выполнены до конца.</p>

<p>Стандартная библиотека Rust предоставляет несколько механизмов для синхронизации
двух потоков друг с другом. Давайте поговорим об одном из них: каналах.</p>

<h2 id="Каналы" class='section-header'><a
                           href="#Каналы">Каналы</a></h2>
<p>А вот версия нашего кода, которая использует каналы для синхронизации, вместо
того чтобы ждать в течение определенного времени:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Arc</span>, <span class='ident'>Mutex</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>mpsc</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='number'>0u32</span>));

    <span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>mpsc</span>::<span class='ident'>channel</span>();

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>let</span> (<span class='ident'>data</span>, <span class='ident'>tx</span>) <span class='op'>=</span> (<span class='ident'>data</span>.<span class='ident'>clone</span>(), <span class='ident'>tx</span>.<span class='ident'>clone</span>());

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
            <span class='op'>*</span><span class='ident'>data</span> <span class='op'>+=</span> <span class='number'>1</span>;

            <span class='ident'>tx</span>.<span class='ident'>send</span>(());
        });
    }

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='ident'>rx</span>.<span class='ident'>recv</span>();
    }
}
</pre>

<p>Мы используем метод <code>mpsc::channel()</code>, чтобы построить новый канал. В этом
примере мы в каждом из десяти потоков вызываем метод <code>send</code>, который передает по
каналу простое значение <code>()</code>, а затем в главном потоке ждем, пока не будут
приняты все десять значений.</p>

<p>В то время как по этому каналу послается просто общий сигнал, в общем случае мы
можем отправить по каналу любые данные, которые реализуют трейт <code>Send</code>!</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>mpsc</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>mpsc</span>::<span class='ident'>channel</span>();

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>tx</span> <span class='op'>=</span> <span class='ident'>tx</span>.<span class='ident'>clone</span>();

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='number'>42u32</span>;

            <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='ident'>answer</span>);
        });
    }

   <span class='ident'>rx</span>.<span class='ident'>recv</span>().<span class='ident'>ok</span>().<span class='ident'>expect</span>(<span class='string'>&quot;Could not receive answer&quot;</span>);
}
</pre>

<p><code>u32</code> реализует <code>Send</code> потому что мы можем сделать копию. Итак, создается поток,
в котором вычисляется ответ, а затем этот ответ с помощью метода <code>send()</code>
передается обратно по каналу.</p>

<h2 id="Паника" class='section-header'><a
                           href="#Паника">Паника</a></h2>
<p><code>panic!</code> аварийно завершает выполняемый в данный момент поток. Вы можете
использовать потоки Rust, как простой механизм изоляции:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;oops!&quot;</span>);
}).<span class='ident'>join</span>();

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>result</span>.<span class='ident'>is_err</span>());
</pre>

<p><code>Thread</code> возвращает <code>Result</code>, что позволяет нам проверить, произошло ли
завершение потока в результате паники или нет.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>