<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Unsafe and Low-Level Code</title>

    <link rel="stylesheet" type="text/css" href="rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a href='basic.html'><b>2.</b> Начальный Rust</a>
<ul class='section'>
<li><a href='installing-rust.html'><b>2.1.</b> Установка Rust</a>
</li>
<li><a href='hello-world.html'><b>2.2.</b> Hello, world!</a>
</li>
<li><a href='hello-cargo.html'><b>2.3.</b> Hello, Cargo!</a>
</li>
<li><a href='variable-bindings.html'><b>2.4.</b> Связывание переменных</a>
</li>
<li><a href='if.html'><b>2.5.</b> Условные переходы (If)</a>
</li>
<li><a href='functions.html'><b>2.6.</b> Функции</a>
</li>
<li><a href='comments.html'><b>2.7.</b> Комментарии</a>
</li>
<li><a href='compound-data-types.html'><b>2.8.</b> Агрегатные типы данных</a>
</li>
<li><a href='match.html'><b>2.9.</b> Сопоставление с образцом (Match)</a>
</li>
<li><a href='looping.html'><b>2.10.</b> Циклы</a>
</li>
<li><a href='strings.html'><b>2.11.</b> Строки</a>
</li>
<li><a href='arrays-vectors-and-slices.html'><b>2.12.</b> Массивы, вектора, срезы</a>
</li>
</ul>
</li>
<li><a href='intermediate.html'><b>3.</b> Средний Rust</a>
<ul class='section'>
<li><a href='crates-and-modules.html'><b>3.1.</b> Крейты и модули</a>
</li>
<li><a href='testing.html'><b>3.2.</b> Тестирование</a>
</li>
<li><a href='pointers.html'><b>3.3.</b> Указатели</a>
</li>
<li><a href='ownership.html'><b>3.4.</b> Владение</a>
</li>
<li><a href='more-strings.html'><b>3.5.</b> Больше о строках</a>
</li>
<li><a href='patterns.html'><b>3.6.</b> Шаблоны</a>
</li>
<li><a href='method-syntax.html'><b>3.7.</b> Синтаксис методов</a>
</li>
<li><a href='associated-types.html'><b>3.8.</b> Ассоциированные типы</a>
</li>
<li><a href='closures.html'><b>3.9.</b> Замыкания</a>
</li>
<li><a href='iterators.html'><b>3.10.</b> Итераторы</a>
</li>
<li><a href='generics.html'><b>3.11.</b> Дженерики</a>
</li>
<li><a href='traits.html'><b>3.12.</b> Трейты</a>
</li>
<li><a href='static-and-dynamic-dispatch.html'><b>3.13.</b> Статическая и динамическая диспетчерезация</a>
</li>
<li><a href='macros.html'><b>3.14.</b> Макросы</a>
</li>
<li><a href='concurrency.html'><b>3.15.</b> Многозадачность</a>
</li>
<li><a href='error-handling.html'><b>3.16.</b> Обработка ошибок</a>
</li>
<li><a href='documentation.html'><b>3.17.</b> Документация</a>
</li>
</ul>
</li>
<li><a href='advanced.html'><b>4.</b> Продвинутый Rust</a>
<ul class='section'>
<li><a href='ffi.html'><b>4.1.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a href='unsafe.html'><b>4.2.</b> Небезопасный код</a>
</li>
<li><a href='advanced-macros.html'><b>4.3.</b> Продвинутые макросы</a>
</li>
</ul>
</li>
<li><a href='unstable.html'><b>5.</b> Нестабильный Rust</a>
<ul class='section'>
<li><a href='plugins.html'><b>5.1.</b> Плагины компилятора</a>
</li>
<li><a href='inline-assembly.html'><b>5.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a href='no-stdlib.html'><b>5.3.</b> Без stdlib</a>
</li>
<li><a href='intrinsics.html'><b>5.4.</b> Intrinsics</a>
</li>
<li><a href='lang-items.html'><b>5.5.</b> Lang items</a>
</li>
<li><a href='link-args.html'><b>5.6.</b> Link args</a>
</li>
</ul>
</li>
<li><a href='conclusion.html'><b>6.</b> Заключение</a>
</li>
<li><a href='glossary.html'><b>7.</b> Глоссарий</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Unsafe and Low-Level Code</h1>
    
<h1 id="introduction" class='section-header'><a
                           href="#introduction">Introduction</a></h1>
<p>Rust aims to provide safe abstractions over the low-level details of
the CPU and operating system, but sometimes one needs to drop down and
write code at that level. This guide aims to provide an overview of
the dangers and power one gets with Rust&#39;s unsafe subset.</p>

<p>Rust provides an escape hatch in the form of the <code>unsafe { ... }</code>
block which allows the programmer to dodge some of the compiler&#39;s
checks and do a wide range of operations, such as:</p>

<ul>
<li>dereferencing <a href="#raw-pointers">raw pointers</a></li>
<li>calling a function via FFI (<a href="ffi.html">covered by the FFI guide</a>)</li>
<li>casting between types bitwise (<code>transmute</code>, aka &quot;reinterpret cast&quot;)</li>
<li><a href="#inline-assembly">inline assembly</a></li>
</ul>

<p>Note that an <code>unsafe</code> block does not relax the rules about lifetimes
of <code>&amp;</code> and the freezing of borrowed data.</p>

<p>Any use of <code>unsafe</code> is the programmer saying &quot;I know more than you&quot; to
the compiler, and, as such, the programmer should be very sure that
they actually do know more about why that piece of code is valid.  In
general, one should try to minimize the amount of unsafe code in a
code base; preferably by using the bare minimum <code>unsafe</code> blocks to
build safe interfaces.</p>

<blockquote>
<p><strong>Note</strong>: the low-level details of the Rust language are still in
flux, and there is no guarantee of stability or backwards
compatibility. In particular, there may be changes that do not cause
compilation errors, but do cause semantic changes (such as invoking
undefined behaviour). As such, extreme care is required.</p>
</blockquote>

<h1 id="pointers" class='section-header'><a
                           href="#pointers">Pointers</a></h1>
<h2 id="references" class='section-header'><a
                           href="#references">References</a></h2>
<p>One of Rust&#39;s biggest features is memory safety.  This is achieved in
part via <a href="ownership.html">the ownership system</a>, which is how the
compiler can guarantee that every <code>&amp;</code> reference is always valid, and,
for example, never pointing to freed memory.</p>

<p>These restrictions on <code>&amp;</code> have huge advantages. However, they also
constrain how we can use them. For example, <code>&amp;</code> doesn&#39;t behave
identically to C&#39;s pointers, and so cannot be used for pointers in
foreign function interfaces (FFI). Additionally, both immutable (<code>&amp;</code>)
and mutable (<code>&amp;mut</code>) references have some aliasing and freezing
guarantees, required for memory safety.</p>

<p>In particular, if you have an <code>&amp;T</code> reference, then the <code>T</code> must not be
modified through that reference or any other reference. There are some
standard library types, e.g. <code>Cell</code> and <code>RefCell</code>, that provide inner
mutability by replacing compile time guarantees with dynamic checks at
runtime.</p>

<p>An <code>&amp;mut</code> reference has a different constraint: when an object has an
<code>&amp;mut T</code> pointing into it, then that <code>&amp;mut</code> reference must be the only
such usable path to that object in the whole program. That is, an
<code>&amp;mut</code> cannot alias with any other references.</p>

<p>Using <code>unsafe</code> code to incorrectly circumvent and violate these
restrictions is undefined behaviour. For example, the following
creates two aliasing <code>&amp;mut</code> pointers, and is invalid.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>let</span> <span class='ident'>ref_1</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>u8</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;
<span class='kw'>let</span> <span class='ident'>ref_2</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>u8</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>ref_1</span>) };

<span class='comment'>// oops, ref_1 and ref_2 point to the same piece of data (x) and are</span>
<span class='comment'>// both usable</span>
<span class='op'>*</span><span class='ident'>ref_1</span> <span class='op'>=</span> <span class='number'>10</span>;
<span class='op'>*</span><span class='ident'>ref_2</span> <span class='op'>=</span> <span class='number'>20</span>;
</pre>

<h2 id="raw-pointers" class='section-header'><a
                           href="#raw-pointers">Raw pointers</a></h2>
<p>Rust offers two additional pointer types (<em>raw pointers</em>), written as
<code>*const T</code> and <code>*mut T</code>. They&#39;re an approximation of C&#39;s <code>const T*</code> and <code>T*</code>
respectively; indeed, one of their most common uses is for FFI,
interfacing with external C libraries.</p>

<p>Raw pointers have much fewer guarantees than other pointer types
offered by the Rust language and libraries. For example, they</p>

<ul>
<li>are not guaranteed to point to valid memory and are not even
guaranteed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</li>
<li>do not have any automatic clean-up, unlike <code>Box</code>, and so require
manual resource management;</li>
<li>are plain-old-data, that is, they don&#39;t move ownership, again unlike
<code>Box</code>, hence the Rust compiler cannot protect against bugs like
use-after-free;</li>
<li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot
reason about dangling pointers; and</li>
<li>have no guarantees about aliasing or mutability other than mutation
not being allowed directly through a <code>*const T</code>.</li>
</ul>

<p>Fortunately, they come with a redeeming feature: the weaker guarantees
mean weaker restrictions. The missing restrictions make raw pointers
appropriate as a building block for implementing things like smart
pointers and vectors inside libraries. For example, <code>*</code> pointers are
allowed to alias, allowing them to be used to write shared-ownership
types like reference counted and garbage collected pointers, and even
thread-safe shared memory types (<code>Rc</code> and the <code>Arc</code> types are both
implemented entirely in Rust).</p>

<p>There are two things that you are required to be careful about
(i.e. require an <code>unsafe { ... }</code> block) with raw pointers:</p>

<ul>
<li>dereferencing: they can have any value: so possible results include
a crash, a read of uninitialised memory, a use-after-free, or
reading data as normal.</li>
<li>pointer arithmetic via the <code>offset</code> <a href="#intrinsics">intrinsic</a> (or
<code>.offset</code> method): this intrinsic uses so-called &quot;in-bounds&quot;
arithmetic, that is, it is only defined behaviour if the result is
inside (or one-byte-past-the-end) of the object from which the
original pointer came.</li>
</ul>

<p>The latter assumption allows the compiler to optimize more
effectively. As can be seen, actually <em>creating</em> a raw pointer is not
unsafe, and neither is converting to an integer.</p>

<h3 id="references-and-raw-pointers" class='section-header'><a
                           href="#references-and-raw-pointers">References and raw pointers</a></h3>
<p>At runtime, a raw pointer <code>*</code> and a reference pointing to the same
piece of data have an identical representation. In fact, an <code>&amp;T</code>
reference will implicitly coerce to an <code>*const T</code> raw pointer in safe code
and similarly for the <code>mut</code> variants (both coercions can be performed
explicitly with, respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>

<p>Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not
safe. A <code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer
<code>*const T</code> has to point to a valid instance of type <code>T</code>. Furthermore,
the resulting pointer must satisfy the aliasing and mutability laws of
references. The compiler assumes these properties are true for any
references, no matter how they are created, and so any conversion from
raw pointers is asserting that they hold. The programmer <em>must</em>
guarantee this.</p>

<p>The recommended method for the conversion is</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>let</span> <span class='ident'>i</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='comment'>// explicit cast</span>
<span class='kw'>let</span> <span class='ident'>p_imm</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>2</span>;
<span class='comment'>// implicit coercion</span>
<span class='kw'>let</span> <span class='ident'>p_mut</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>m</span>;

<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>ref_imm</span>: <span class='kw-2'>&amp;</span><span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>p_imm</span>;
    <span class='kw'>let</span> <span class='ident'>ref_mut</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='ident'>p_mut</span>;
}
</pre>

<p>The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>.
The latter is far more powerful than necessary, and the more
restricted operation is harder to use incorrectly; for example, it
requires that <code>x</code> is a pointer (unlike <code>transmute</code>).</p>

<h2 id="making-the-unsafe-safe(r)" class='section-header'><a
                           href="#making-the-unsafe-safe(r)">Making the unsafe safe(r)</a></h2>
<p>There are various ways to expose a safe interface around some unsafe
code:</p>

<ul>
<li>store pointers privately (i.e. not in public fields of public
structs), so that you can see and control all reads and writes to
the pointer in one place.</li>
<li>use <code>assert!()</code> a lot: since you can&#39;t rely on the protection of the
compiler &amp; type-system to ensure that your <code>unsafe</code> code is correct
at compile-time, use <code>assert!()</code> to verify that it is doing the
right thing at run-time.</li>
<li>implement the <code>Drop</code> for resource clean-up via a destructor, and use
RAII (Resource Acquisition Is Initialization). This reduces the need
for any manual memory management by users, and automatically ensures
that clean-up is always run, even when the thread panics.</li>
<li>ensure that any data stored behind a raw pointer is destroyed at the
appropriate time.</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
</div></div>


</body>
</html>